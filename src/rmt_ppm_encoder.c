/**
 * @file
 * @brief RMT PPM encoder module.
 * @internal
 *
 * @copyright (C) 2025 Melexis N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @endinternal
 *
 * @ingroup lib_ppm_bootloader
 *
 * @details Implementations of the RMT PPM encoder module.
 */
#include <stdint.h>
#include <stdlib.h>

#include "hal/hal_utils.h"
#include "driver/rmt_encoder.h"
#include "esp_check.h"
#include "esp_attr.h"
#include "esp_log.h"
#include "rmt_private.h"

#include "ppm_types.h"

#include "rmt_ppm_encoder.h"

static const char *TAG = "rmt_ppm_encoder";

#ifndef MIN
   #define MIN(x, y) ((x) < (y)?(x):(y))
#endif

typedef struct rmt_ppm_encoder_t {
    rmt_encoder_t base;                 /**< encoder base class */
    ppm_frame_type_t last_frame_type;   /**< current ongoing PPM frame type */
    size_t last_byte_index;             /**< current byte index */
    int last_bits_offset;               /**< current bit pair index (0, 2, 4, 6) */
} rmt_ppm_encoder_t;


/** Reset implementation
 */
static esp_err_t rmt_ppm_encoder_reset(rmt_encoder_t *encoder) {
    rmt_ppm_encoder_t *ppm_encoder = __containerof(encoder, rmt_ppm_encoder_t, base);
    // reset index to zero
    ppm_encoder->last_frame_type = ftUnknown;
    ppm_encoder->last_byte_index = 0;
    ppm_encoder->last_bits_offset = 0;
    return ESP_OK;
}

/** Encoder implementation
 */
static size_t IRAM_ATTR rmt_encode_ppm(rmt_encoder_t *encoder,
                                       rmt_channel_handle_t channel,
                                       const void *primary_data,
                                       size_t data_size,
                                       rmt_encode_state_t *ret_state) {
    rmt_ppm_encoder_t *ppm_encoder = __containerof(encoder, rmt_ppm_encoder_t, base);
    rmt_tx_channel_t *tx_chan = __containerof(channel, rmt_tx_channel_t, base);
    const uint8_t *raw_data = (const uint8_t *)primary_data;
    rmt_encode_state_t state = RMT_ENCODING_RESET;
    rmt_dma_descriptor_t *desc0 = NULL;
    rmt_dma_descriptor_t *desc1 = NULL;

    size_t byte_index = ppm_encoder->last_byte_index;
    size_t bits_offset = ppm_encoder->last_bits_offset;

    if ((bits_offset == 0) && (byte_index == 0)) {
        /* first byte in the buffer is the frame type to be transmitted */
        ppm_encoder->last_frame_type = raw_data[byte_index];
        byte_index++;
    }

    /* determine the number symbols generated by the encoder */
    size_t mem_want = 0;
    switch (ppm_encoder->last_frame_type) {
        case ftSession:
        case ftPage:
            mem_want = ((data_size - byte_index) * 8 + (8 - bits_offset)) / 2;
            if ((bits_offset == 0) && (byte_index == 1)) {
                mem_want += 2; /* add frame type pulse */
            }
            break;
        case ftCalibration:
            mem_want = 9 - bits_offset;
            break;
        case ftEnter_Ppm:
            mem_want = data_size + 1 - byte_index;
            break;
        case ftUnknown:
            /* this should not happen */
            state |= RMT_ENCODING_COMPLETE;
            *ret_state = state;
            return 0;
    }

    /* how many symbols we can save for this round */
    size_t mem_have = tx_chan->mem_end - tx_chan->mem_off;

    /* get location to put the encoded symbols */
    rmt_symbol_word_t *mem_to_nc = NULL;
    if (channel->dma_chan) {
        mem_to_nc = tx_chan->dma_mem_base_nc;
    } else {
        mem_to_nc = channel->hw_mem_base;
    }

    /* how many symbols will be encoded in this round */
    size_t encode_len = MIN(mem_want, mem_have);
    bool encoding_truncated = mem_have < mem_want;
    bool encoding_space_free = mem_have > mem_want;

    if (channel->dma_chan) {
        /* mark the start descriptor */
        if (tx_chan->mem_off < tx_chan->ping_pong_symbols) {
            desc0 = &tx_chan->dma_nodes_nc[0];
        } else {
            desc0 = &tx_chan->dma_nodes_nc[1];
        }
    }

    size_t len = encode_len;
    if (ppm_encoder->last_frame_type == ftEnter_Ppm) {
        while (len > 0) {
            uint32_t cur_pulse = ((uint32_t)raw_data[byte_index]) * (4000000 / 1000000);  // ppm_resolution_hz TODO
            mem_to_nc[tx_chan->mem_off].level0 = 1;
            mem_to_nc[tx_chan->mem_off].duration0 = cur_pulse / 4;
            mem_to_nc[tx_chan->mem_off].level1 = 0;
            mem_to_nc[tx_chan->mem_off].duration1 = 3 * cur_pulse / 4;
            tx_chan->mem_off++;
            len--;
            byte_index++;
        }
    } else if (ppm_encoder->last_frame_type == ftCalibration) {
        while (len > 0) {
            mem_to_nc[tx_chan->mem_off].level0 = 1;
            mem_to_nc[tx_chan->mem_off].duration0 = PPM_PULSE_LOW_TIME;
            mem_to_nc[tx_chan->mem_off].level1 = 0;
            mem_to_nc[tx_chan->mem_off].duration1 = PPM_CALIB_PULSE_TIME - PPM_PULSE_LOW_TIME;
            tx_chan->mem_off++;
            len--;
            bits_offset++;
        }
    } else if ((ppm_encoder->last_frame_type == ftSession) || (ppm_encoder->last_frame_type == ftPage)) {
        if ((bits_offset == 0) && (byte_index == 1)) {
            /* generate frame type pulse */
            mem_to_nc[tx_chan->mem_off].level0 = 0;
            mem_to_nc[tx_chan->mem_off].duration0 = PPM_PULSE_LOW_TIME;
            mem_to_nc[tx_chan->mem_off].level1 = 1;
            mem_to_nc[tx_chan->mem_off].duration1 = PPM_PULSE_LOW_TIME;
            tx_chan->mem_off++;
            len--;
            mem_to_nc[tx_chan->mem_off].level0 = 0;
            if (ppm_encoder->last_frame_type == ftSession) {
                mem_to_nc[tx_chan->mem_off].duration0 = PPM_SESSION_PULSE_TIME - PPM_PULSE_LOW_TIME;
            } else {
                mem_to_nc[tx_chan->mem_off].duration0 = PPM_PAGE_PULSE_TIME - PPM_PULSE_LOW_TIME;
            }
            mem_to_nc[tx_chan->mem_off].level1 = 1;
            mem_to_nc[tx_chan->mem_off].duration1 = PPM_PULSE_LOW_TIME;
            tx_chan->mem_off++;
            len--;
        }

        while (len > 0) {
            /* start from last time truncated encoding */
            uint8_t cur_byte = raw_data[byte_index];
            while ((len > 0) && (bits_offset < 8)) {
                /* transfer MSbits first */
                uint8_t two_bits = (cur_byte >> (6 - bits_offset)) & 0x03;
                uint32_t total_time = 18 + (two_bits * PPM_BIT_DISTANCE);   /* 4.5us + (0~3*1.5us) */
                mem_to_nc[tx_chan->mem_off].level0 = 0;
                mem_to_nc[tx_chan->mem_off].duration0 = total_time - PPM_PULSE_LOW_TIME;
                mem_to_nc[tx_chan->mem_off].level1 = 1;
                mem_to_nc[tx_chan->mem_off].duration1 = PPM_PULSE_LOW_TIME;
                tx_chan->mem_off++;
                len--;
                bits_offset += 2;
            }
            if (bits_offset >= 8) {
                /* prepare for next byte */
                byte_index++;
                bits_offset = 0;
            }
        }
    } else {
        /* empty */
    }

    if (channel->dma_chan) {
        /* mark the end descriptor */
        if (tx_chan->mem_off < tx_chan->ping_pong_symbols) {
            desc1 = &tx_chan->dma_nodes_nc[0];
        } else {
            desc1 = &tx_chan->dma_nodes_nc[1];
        }

        /* cross line, means desc0 has prepared with sufficient data buffer */
        if (desc0 != desc1) {
            desc0->dw0.length = tx_chan->ping_pong_symbols * sizeof(rmt_symbol_word_t);
            desc0->dw0.owner = DMA_DESCRIPTOR_BUFFER_OWNER_DMA;
        }
    }

    if (encoding_truncated) {
        /* this encoding has not finished yet, save the truncated position */
        ppm_encoder->last_bits_offset = bits_offset;
        ppm_encoder->last_byte_index = byte_index;
    } else {
        /* reset internal index if encoding session has finished */
        ppm_encoder->last_bits_offset = 0;
        ppm_encoder->last_byte_index = 0;
        state |= RMT_ENCODING_COMPLETE;
    }

    if (!encoding_space_free) {
        /* no more free memory, the caller should yield */
        state |= RMT_ENCODING_MEM_FULL;
    }

    /* reset offset pointer when exceeds maximum range */
    if (tx_chan->mem_off >= tx_chan->ping_pong_symbols * 2) {
        if (channel->dma_chan) {
            desc1->dw0.length = tx_chan->ping_pong_symbols * sizeof(rmt_symbol_word_t);
            desc1->dw0.owner = DMA_DESCRIPTOR_BUFFER_OWNER_DMA;
        }
        tx_chan->mem_off = 0;
    }

    *ret_state = state;
    return encode_len;
}

/** Delete implementation
 */
static esp_err_t rmt_del_ppm_encoder(rmt_encoder_t *encoder) {
    rmt_ppm_encoder_t *ppm_encoder = __containerof(encoder, rmt_ppm_encoder_t, base);
    free(ppm_encoder);
    return ESP_OK;
}

/** Create encoder
 */
esp_err_t rmt_ppm_encoder_new(const rmt_ppm_encoder_config_t *config, rmt_encoder_handle_t *ret_encoder) {
    esp_err_t ret = ESP_OK;
    ESP_GOTO_ON_FALSE(config && ret_encoder, ESP_ERR_INVALID_ARG, err, TAG, "invalid argument");
    rmt_ppm_encoder_t *ppm_encoder = rmt_alloc_encoder_mem(sizeof(rmt_ppm_encoder_t));
    ESP_GOTO_ON_FALSE(ppm_encoder, ESP_ERR_NO_MEM, err, TAG, "no mem for bytes encoder");
    ppm_encoder->base.encode = rmt_encode_ppm;
    ppm_encoder->base.del = rmt_del_ppm_encoder;
    ppm_encoder->base.reset = rmt_ppm_encoder_reset;
    // return general encoder handle
    *ret_encoder = &ppm_encoder->base;
    ESP_LOGD(TAG, "new bytes encoder @%p", ppm_encoder);
err:
    return ret;
}

esp_err_t rmt_ppm_encoder_delete(rmt_encoder_handle_t encoder) {
    rmt_ppm_encoder_t *ppm_encoder = __containerof(encoder, rmt_ppm_encoder_t, base);
    return rmt_del_ppm_encoder(&ppm_encoder->base);
}

